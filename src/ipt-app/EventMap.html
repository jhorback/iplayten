<script>
/**
 This mixin allows you to declare dom events that are
    attached and detatched automatically when the element is 
    attached or detached from the dom.

    ## Status
    __9/13/2017 - Complete - 11 passing tests__

    ## Basic usage
    When "some-dom-event" is dispatched, the "_someHandler" method gets called;
    __stopPropagation()__ is called on the event before passing it to the handler.

    ```js
    class MyCass extends EventMap(Polymer.Element) {
    static get events() {
        return {
        "some-dom-event": "_someHandler",
        "another-dom-event": "_anotherHandler"
        };
    };

    _someHandler(event) {
        // handle event...
    }

    _anotherHandler(event) {
        // handle event...
    }
    }
    ```
    
    ## Listening at the parent or window
    Each event can be configured to add the listener to its parent
    or to the window object. By default the listeners are attached 
    to the element itself.
    
    ```js
    class MyCass extends EventMap(Polymer.Element) {
    static get events() {
        return {
        "some-dom-event": "_someHandler",
        "event-to-handle-at-parent": {
            listenAt: "parent",
            handler: "_someHandler2"
        },
        "event-to-handle-at-window",  {
            listenAt: "window",
            handler: "_someHandler3"
        }
        };
    };

    _someHandler(event) {
        // handle event...
    }

    _someHandler2(event) {
        // handle event...
    }

        _someHandler3(event) {
        // handle event...
    }
    }
    ```



    @polymer
    @mixinFunction
*/
let EventMap = (superclass) => class extends superclass {
    ready () {
    super.ready();
    this.__eventMapHandlers = {};
    }
    /**
     * Adds event listeners.
     */
    connectedCallback() {
        super.connectedCallback();
    this._bindEvents();
    }
    /**
     * Detaches event listners.
     */
    disconnectedCallback() {
    super.disconnectedCallback();
    this._unbindEvents();
    }

    _bindEvents() {
    
    let events = this.constructor.events;
    if (!events) {
        return;
    }

    this.__eventMapHandlers = {};
    Object.keys(events).forEach((key) => {        

        // support a string or object
        let detail = (typeof events[key] === "string") ? 
        { handler: events[key] } : events[key];
        
        if (!this[detail.handler]) {
        throw new Error(`EventMap method does not exist: ${detail.handler}`);
        }

        let handler = (event) => {
        event.stopPropagation();
        this[detail.handler](event);
        };

        let listenAt = (detail.listenAt) === "window" ? window :
        (detail.listenAt) === "parent" ? this.parentElement : this;
        
        if (!listenAt){
        console.warn("Event map could not listen at", detail.listenAt, "- changing to listen at window");
        listenAt = window;
        }

        this.__eventMapHandlers[key] =  {
        listenAt: listenAt,
        handler: handler
        };

        listenAt.addEventListener(key, handler);
    });    
    }

    _unbindEvents() {
    let handlers = this.__eventMapHandlers;
    
    if (!handlers) {
        return;
    }

    Object.keys(handlers).forEach((key) => {
        let info = handlers[key];
        info.listenAt.removeEventListener(key, info.handler); 
    });

    delete this.__eventMapHandlers;
    }
};

</script>